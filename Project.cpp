#include <iostream>
#include <cmath>
#include <fstream>
#include <string>
#include <iomanip>
using namespace std;

const double PI = acos(-1.0);
const double k = 0.4;
const double p = 1.225;
const double f = 0.0001;
class Windfarm
{
private:
	int a;
	double N;/* number of turbines*/
	int nr, ntr;
	double** x;
	double** y;
	double** induction_factor;
	double Cp;
	double Ct;
	double Cft;
	double Sx, Sy; /*average downwind and crosswind turbine spacing*/
	double D; /*turbine diameter*/
	double Zh; /*turbine hub height*/
	double Z0lo; /*groud roughness length*/
	double Z0hi; /* effective roughness length of a wind farm */
	double u_0; /* unperturbed friction velocity of the incoming wind */
	double** u_a;/*ambient friction velocity*/
	double u_hi; /*total friction velocity including the drags from the wind and the ground or ocean surface in the fully developed region */
	double G;  /* geostrophic wind speed */
	double blt; /* boundary layer thickness */
	double gm; /* gamma fraction to calculate ambient wind speed */
	double Hg; /*height of the fully developed internal boundary layer*/
	double Xfd; /*location where internal boundary layer becomes fully developed */
	double Xsd; /*distance from the upwind edge of the wind farm, which denotes the location where internal boundary layer starts growing */
	double Uh; /*undisturbed wind speed*/
	double Uh_fd; /* horizontally averaged wind speed at turbine hub height in the fully developed region */
	double Ua_fd; /* ambient wind speed in the fully developed region */
	double c_alf; /* coefficient c_alfa */
	double beta; /* coefficient beta */
	double** u; /* incoming velocity for each turbine */
	double** u_old;
	double** Ua; /*ambient wind speed*/
	double** Unw; /*wind speed in the very near wake region*/
	double entrainment_const;
	double Rw; /*the radius of the wake*/
	double** P; /*power generated by turbine*/
	double Uwake; /*the wake velocity */
	double** dU; /*velocity deficit*/
public:
	void getdate()
	{
		fstream myfile;
		string b;

		cout << "enter the number of type of wind farm(1.HornsRev 2.Stagger 3.Align) :  ";
		cin >> a;
		if (a == 1)
		{
			myfile.open("HornsRev");
			if (myfile.is_open())
			{
				getline(myfile, b);
				getline(myfile, b);
				getline(myfile, b);
				getline(myfile, b);
				getline(myfile, b);
				myfile >> blt;/*BL height*/
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> c_alf;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> N; /* number of turbines */
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> G;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Z0lo;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> D;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Zh;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Sx;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Sy;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> gm;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Xsd;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> beta;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> nr;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> ntr;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				getline(myfile, b);
				int i, j;
				x = new double*[nr];
				for (i = 0; i < nr; i++)
					x[i] = new double[ntr];
				y = new double*[nr];
				for (i = 0; i < nr; i++)
					y[i] = new double[ntr];
				induction_factor = new double*[nr];
				for (i = 0; i < nr; i++)
					induction_factor[i] = new double[ntr];

				for (i = 0; i < nr; i++)
				{
					int r;
					for (j = 0; j < ntr; j++)
					{

						myfile >> x[i][j];
						myfile >> y[i][j];
						myfile >> induction_factor[i][j];
						myfile >> r;
					}

				}
				double lol = x[0][0];
				for (i = 0; i < nr; i++)
				{
					for (j = 0; j < ntr; j++)
						x[i][j] = x[i][j] - lol;
				}
				/*test whether read date file rightly*/

				/*for (i = 0; i < nr; i++)
				{
					for (j = 0; j < ntr; j++)
						cout << x[i][j] << '\t' << y[i][j] << endl;
				}*/
				

			}
			else cout << "failed to open" << endl;

		}
		if (a == 2)
		{
			myfile.open("WindTunnel_Stagger");
			if (myfile.is_open())
			{
				
				getline(myfile, b);
				getline(myfile, b);
				getline(myfile, b);
				getline(myfile, b);
				getline(myfile, b);
				myfile >> blt;/*BL height*/
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> c_alf;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> N; /* number of turbines */
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> G;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Z0lo;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> D;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Zh;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Sx;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Sy;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> gm;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Xsd;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> beta;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> nr;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> ntr;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				getline(myfile, b);
				int i, j;
				x = new double*[nr];
				for (i = 0; i < nr; i++)
					x[i] = new double[ntr];
				y = new double*[nr];
				for (i = 0; i < nr; i++)
					y[i] = new double[ntr];
				induction_factor = new double*[nr];
				for (i = 0; i < nr; i++)
					induction_factor[i] = new double[ntr];

				for (j = 0; j < ntr; j++)
				{
					int r;
					for (i = 0; i < nr; i++)
					{

						myfile >> x[i][j];
						myfile >> y[i][j];
						myfile >> induction_factor[i][j];
						myfile >> r;
					}

				}
				/*test whether read date file rightly*/
				/*for (j = 0; j < ntr; j++)
				{
					for (i = 0; i < nr; i++)
						cout << x[i][j] << '\t' << y[i][j] << endl;
				}*/


			}
			else cout << "failed to open" << endl;
		}
		if (a == 3)
		{
			myfile.open("WindTunnel_Align");
			if (myfile.is_open())
			{
				
				getline(myfile, b);
				getline(myfile, b);
				getline(myfile, b);
				getline(myfile, b);
				getline(myfile, b);
				myfile >> blt;/*BL height*/
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> c_alf;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> N; /* number of turbines */
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> G;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Z0lo;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> D;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Zh;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Sx;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Sy;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> gm;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> Xsd;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> beta;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> nr;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				myfile >> ntr;
				myfile.ignore(100, '\n');
				getline(myfile, b);
				getline(myfile, b);
				int i, j;
				x = new double*[nr];
				for (i = 0; i < nr; i++)
					x[i] = new double[ntr];
				y = new double*[nr];
				for (i = 0; i < nr; i++)
					y[i] = new double[ntr];
				induction_factor = new double*[nr];
				for (i = 0; i < nr; i++)
					induction_factor[i] = new double[ntr];

				for (j = 0; j < ntr; j++)
				{
					int r;
					for (i = 0; i < nr; i++)
					{

						myfile >> x[i][j];
						myfile >> y[i][j];
						myfile >> induction_factor[i][j];
						myfile >> r;
					}

				}
				/*test whether read date file rightly*/
				/*for (j = 0; j < ntr; j++)
				{
					for (i = 0; i < nr; i++)
						cout << x[i][j] << '\t' << y[i][j] << endl;
				}*/


			}
			else cout << "failed to open" << endl;
		}

	}

	void Compute_cp_ct()
	{
		if (a == 2)
		{
			Cp = 4 * induction_factor[0][0] * pow((1 - induction_factor[0][0]), 2);
			Ct = 4 * induction_factor[0][0] * (1 - induction_factor[0][0]);
		}
		else
		{
			int i, j;
			for (i = 0; i < nr; i++)
			{
				for (j = 0; j < ntr; j++)
				{
					Cp = 4 * induction_factor[i][j] * pow((1 - induction_factor[i][j]), 2);
					Ct = 4 * induction_factor[i][j] * (1 - induction_factor[i][j]);

				}
			}
		}
		cout << "CP=" << Cp << endl;
		cout << "Ct=" << Ct << endl;
	}

	void Compute_Cft()
	{
		Cft = Ct*PI*pow(D, 2) / (4 * Sx*Sy);
		cout << "Cft=" << Cft << endl;
	}

	void compute_Z0hi()
	{
		Z0hi = Zh*exp((-k) / sqrt(Cft / 2.0 + (k / log(Zh / Z0lo))*(k / log(Zh / Z0lo))));
		cout << "Z0hi=" << Z0hi << endl;
	}

	void Compute_u_0()
	{
		if (a == 1)
		{
			u_0 = (k*G) / log(G / (f*exp(4)*Z0lo));
		}
		else
		{
			u_0 = (k*G) / log(blt / Z0lo);
		}
		cout << "u_0=" << u_0 << endl;
	}

	void Compute_u_hi()
	{
		if (a == 1)
		{
			u_hi = (k*G) / log(G / (f*exp(4)*Z0hi));
		}
		else
		{
			u_hi = (k*G) / log(blt / Z0hi);
		}
		cout << "u_hi=" << u_hi << endl;
	}

	void Compute_Hg()
	{
		Hg = exp((u_hi*log(Z0hi) - u_0*log(Z0lo)) / (u_hi - u_0));
		cout << "Hg=" << Hg << endl;
	}

	void Compute_Xfd()
	{
		Xfd = Xsd + pow(Hg - Zh, 5.0 / 4)*pow(Z0hi, (-1.0 / 4));
		
		cout <<"Xfd="<< Xfd << endl;

	}

	void Compute_u_hub_height()
	{
		Uh = (u_0 / k)*log(Zh / Z0lo);
		Uh_fd = (u_hi / k)*log(Zh / Z0hi);
		Ua_fd = gm*Uh_fd + (1 - gm)*Uh;

		cout << "Uh Uh_fd Ua_fd =" << endl;
		cout << Uh << endl;
		cout << Uh_fd << endl;
		cout << Ua_fd << endl;
	}

	void Compute_incoming_wind_speed()
	{
		int i, j, m, k;
		/* initialize arrays */
		u = new double*[nr];
		for (i = 0; i < nr; i++)
			u[i] = new double[ntr];
		u_a = new double*[nr];
		for (i = 0; i < nr; i++)
			u_a[i] = new double[ntr];
		Ua = new double*[nr];
		for (i = 0; i < nr; i++)
			Ua[i] = new double[ntr];
		u_old = new double*[nr];
		for (i = 0; i < nr; i++)
			u_old[i] = new double[ntr];
		dU = new double*[nr];
		for (i = 0; i < nr; i++)
			dU[i] = new double[ntr];
		Unw = new double*[nr];
		for (i = 0; i < nr; i++)
			Unw[i] = new double[ntr];


		/* loop for computing */
		for (k = 0; k < nr; k++)
		{
			for (m = 0; m < ntr; m++)
				u[k][m] = Uh;
		}


		for (i = 0; i < nr; i++)
		{
			/*  save the turbine incoming velocity for computing du and superimposing velocity deﬁcits from different turbine wakes  */
			for (k = i + 1; k < nr; k++)
				for (m = 0; m < ntr; m++)
					u_old[k][m] = u[k][m];
			
			/*  loop over the turbines in ith row  */
			for (j = 0; j < ntr; j++)
			{
				/*Compute friction velocity u*a for the jth turbine in the ith row using Eq. (10) */
				if (x[i][j] < (beta*Xfd))
					u_a[i][j] = u_0;
				if ((beta*Xfd) <= x[i][j] && x[i][j] < Xfd)
					u_a[i][j] = (1.0 - ((x[i][j] - beta*Xfd) / (1.0 - beta)*Xfd))*u_0 +( (x[i][j] - beta*Xfd)*u_hi )/ ((1.0 - beta)*Xfd);
				if (x[i][j] >= Xfd)
				{
					u_a[i][j] = u_hi;
				}
				/*Compute ambient velocity Ua for the jth turbine in the ith row using Eq. (9)*/
				if (x[i][j] < Xfd)
				{
					Ua[i][j] = (1.0 -( x[i][j] / Xfd) )*Uh + (x[i][j] / Xfd)*Ua_fd;
				}
				if (x[i][j] >= Xfd)
				{
					Ua[i][j] = Ua_fd;
				}

				/* The wake from the jth turbine in the ith row may inﬂuence the incoming velocity of all downwind turbines */
				/*  Update the incoming velocity for all the downwind turbines  */
				for (k = i + 1; k<nr; k++)
					for (m = 0; m < ntr; m++)
					{
						/* Compute the streamwise & spanwise separations from the jth turbine in ith row to the mth turbine in kth row:  */
						Sx = x[k][m] - x[i][j];
						Sy = abs(y[k][m] - y[i][j]);

						/*Compute the velocity in the near wake of the jth turbine in ith row: Unw (Eq. (14)) */
						Unw[i][j] = (1.0 - 2.0 * induction_factor[0][0])*u[i][j];

						/*Compute the entrainment constant 𝛼 (Eq.(13)) */
						entrainment_const = c_alf*u_a[i][j] / Unw[i][j];
						

						/*Compute the wake radius of the jth turbine in ith row at Sx:  Rwake (Eq. (12)); */
						if (Sx < D)
							Rw = D / 2.0;
						if (Sx >= D)
							Rw = D / 2.0 + entrainment_const*(Sx - D);

						if (Sy <= Rw)
						{
							/*Compute the wake velocity of the jth turbine in ith row at Sx; Uwake*/
							if (Sx < D)
							{
								Uwake = Unw[i][j] ;
							}
							if (Sx >= D)
							{
								Uwake = Ua[i][j]*(1.0 / 2.0 * (Unw[i][j] / Ua[i][j] + pow(pow(Unw[i][j] / Ua[i][j], 2.0) + 4 * (1 - pow(D / (2.0 * Rw), 2.0))*(1 - Unw[i][j] / Ua[i][j]), 1.0 / 2)));
							}

							/*Compute velocity deﬁcit*/

							dU[k][m] = Uwake - u_old[k][m];

							/*Update incoming velocity for the mth turbine in kth row*/
							u[k][m] += dU[k][m];
						}
					}
			}
		}
	}

	void Compute_power()
	{
		int i, j;
		P = new double*[nr];
		for (i = 0; i < nr; i++)
			P[i] = new double[ntr];
		for (i = 0; i < nr; i++)
		{
			for (j = 0; j<ntr; j++)
				P[i][j] = ( Cp*p*PI*pow(D / 2.0, 2)*pow(u[i][j], 3))/2.0;
		}

	}

	void display()
	{
		int i, j;
		for (i = 0; i < nr; i++)
		{
			cout << "power generated by " << i+1 << " row: ";
			for (j = 0; j < ntr; j++)
			{
				cout << "\t" << P[i][j];
			}
			cout << endl;
		}

		for (i = 0; i < nr; i++)
		{
			for (j = 0; j < ntr; j++)
				cout << " u["<<i<<"]["<<j<<"]=" << u[i][j] << endl;
		}
	
	}
};
int main()
{

	Windfarm W1;
	W1.getdate();
	W1.Compute_cp_ct();
	W1.Compute_Cft();
	W1.compute_Z0hi();
	W1.Compute_u_0();
	W1.Compute_u_hi();
	W1.Compute_Hg();
	W1.Compute_Xfd();
	W1.Compute_u_hub_height();
	W1.Compute_incoming_wind_speed();
	W1.Compute_power();
	W1.display();


	return 0;
}